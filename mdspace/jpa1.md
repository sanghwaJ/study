# JPA (Java Persistence API)

## 1. ORM (Object-Relational Mapping)
- 어플리케이션 Class와 RDB(Relational DataBase)의 테이블을 매핑하는 것
- 즉, 객체와 RDB를 매핑해주기 때문에 SQL문을 작성할 필요가 없으며, 어떤 RDB를 사용하여도 무관함
- 기술적인 의미로는 어플리케이션의 객체를 RDB 테이블에 영속화 해주는 것
- 이러한 역할을 위해 Java는 JDBC를 지원하는데, 이는 매핑 작업을 개발자가 일일히 수행해야하는 단점이 있기 때문에 ORM을 주로 사용함
  
### 1-1. ORM의 장점
- SQL문이 아닌 Method로 DB를 조작하여 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데에 집중할 수 있음
- Query와 같은 선언문, 할당 등의 부수적인 코드가 줄어들고, 각종 객체에 대한 코드를 별도 작성하여 코드의 가독성을 높임
- 객체지향 접근만 고려하여, 객체지향적인 코드 작성이 가능함
- 매핑하는 정보가 Class로 명시되어 있어 ERD를 보는 의존도를 낮추고, 유지보수 및 리팩토링에 유리함

### 1-2. ORM의 단점
- 프로젝트 설계가 잘못된 경우, 속도 저하 및 일관성을 저해할 수 있음
- 복잡하고 무거운 Query는 속도를 위해 튜닝이 필요하기 때문에 결국 SQL문을 사용해야 할 수 도 있음

## 2. JPA (Java Persistence API)
- Java ORM 기술에 대한 API 표준 명세로, 어플리케이션과 JDBC 사이에서 SQL을 호출하고 DB와 통신하는 역할을 함
- JPA가 제공하는 API를 사용하면 객체를 DB에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하지 않아도 됨
- JPA가 개발자 대신 적절한 SQL을 생성해서 DB에 전달하고, 객체가 자동으로 Mapping 됨
- JPA는 내부적으로 JDBC API를 활용하는데, 개발자가 직접 JDBC API를 활용하면 패러다임 불일치, SQL 의존성 등으로 인해 효율성이 떨어지게됨. 이 때, JPA를 활용한다면 모든 SQL에 대해 개발자 대신 JPA가 자동으로 해결해 준다는 점에서 생산성을 크게 높여줌

### ※ Hibernate
- ORM 프레임워크 중 가장 많이 사용되는 오픈소스. Hibernate 기반으로 만들어진 ORM 기술 표준이 JPA이며, 즉, JPA라는 ORM 기술 표준을 구현한 것이 Hibernate이므로, JPA를 사용하려면 Hibernate를 사용하면 된다.

### 2-1. JPA의 장점
- 1차캐시, 쓰기지연, 변경감지, 지연로딩을 제공하여 성능상 이점이 있음
- 코드레벨로 관리되기 때문에, 사용이 편리하고 코드 생산성이 높음
- RDB에 종속적이지 않으므로, 특정 쿼리를 사용하지 않아 추상적으로 기술 구현이 가능함
- 컴파일 타임에 오류를 확인할 수 있음
- 엔티티로 관리되므로 스키마 변경시 엔티티만 수정하게 되면 엔티티를 사용하는 관련 쿼리는 자동으로 변경된 내역이 반영됨
- 객체지향적으로 데이터를 관리할 수 있음
- 부족한 부분은 다양한 쿼리 빌더와 호환하여 보안할 수 있음

### 2-2. JPA의 단점
- JPA만 사용하여 복잡한 연산을 수행하기에는 다소 무리가 있음 (로직이 복잡하거나 불필요한 쿼리가 발생할 수 있다.)
- 초기에는 생산성이 높을 수 있으나 점차 사용하다 보면 성능상 이슈가 발생할 수 있음 (N+1, FetchType, Proxy, 연관관계)
- 고도화 될수록 학습 곡선이 높아질 수 있음 (성능 이슈의 연장선으로 해결 방안에 따라 복잡한 내부 로직을 이해해야 할 필요가 있다)

## ※ MyBatis (SQL Mapper)
- SQL Mapper를 지원해주는 프레임워크로, SQL문을 이용하여 RDB에 접근하고 데이터를 객체화시켜줌
- SQL을 직접 작성하여 Query 수행 결과를 객체와 매핑하고, Query는 xml 파일에 작성
- Query를 직접 작성하므로 복잡한 Query나 최적화된 Query를 구현할 수 있으나, 스키마 변경 시 Query를 직접 수정해주어야 함
- 객체와 Query를 모두 관리하고, CRUD 메소드를 직접 구현해야하는 단점이 있음
- 컴파일 시 오류를 확인 할 수 있는 JPA와 달리, 런타임 시 오류를 확인할 수 있음
- 학습이 어려운 JPA와 달리, Query를 작성할 수 있다면 상대적으로 학습 난이도가 낮음